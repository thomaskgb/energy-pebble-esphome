# API component for Energy Pebble - Using capture_response
# Based on ESPHome documentation example

# HTTP request component
http_request:
  useragent: ESPHome
  timeout: 15s
  verify_ssl: false
  id: http_request_data
  watchdog_timeout: 15s

# Global variables to store the fetched data
globals:
  - id: current_hour_color
    type: std::string
    initial_value: '"G"'
  - id: next_12_hours
    type: std::string
    initial_value: '"G,G,G,G,G,G,G,G,G,G,G,G"'
  - id: api_fetch_success
    type: bool
    initial_value: 'false'

# Text sensors to show the data
text_sensor:
  - platform: template
    name: "Current Hour Color"
    id: current_color_code
    lambda: |-
      return id(current_hour_color);
    update_interval: 30s

  - platform: template
    name: "Next 12 Hours Colors"
    id: next_12_hours_colors
    lambda: |-
      return id(next_12_hours);
    update_interval: 30s

  - platform: template
    name: "API Status"
    id: api_status
    lambda: |-
      if (id(api_fetch_success)) {
        return std::string("Connected");
      } else {
        return std::string("Error");
      }

# Button to manually trigger API fetch
button:
  - platform: template
    name: "Test API Call"
    id: test_api
    on_press:
      - script.execute: simple_api_call

# Interval to automatically fetch data every 15 minutes
interval:
  - interval: 15min
    then:
      - script.execute: simple_api_call

# Simple script - call API and log full JSON response
script:
  - id: simple_api_call
    then:
      - logger.log: "Making API call..."
      - http_request.get:
          id: http_request_data
          url: "https://energypebble.tdlx.nl/api/color-code"
          capture_response: true
          on_response:
            then:
              - logger.log: "Got API response"
              - lambda: |-
                  if (response->status_code == 200) {
                    ESP_LOGD("API", "API call successful");
                    
                    // Parse JSON to extract color codes
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["hour_color_codes"]) {
                        JsonArray hour_codes = root["hour_color_codes"];
                        int total_hours = hour_codes.size();
                        
                        if (total_hours > 0) {
                          // Get current hour (first element)
                          JsonObject first_hour = hour_codes[0];
                          if (first_hour["color_code"]) {
                            const char* current_color = first_hour["color_code"];
                            id(current_hour_color) = std::string(current_color);
                          }
                          
                          // Build string for next 12 hours
                          std::string next_hours = "";
                          int hours_to_show = std::min(12, total_hours);
                          for (int i = 0; i < hours_to_show; i++) {
                            if (i > 0) next_hours += ",";
                            JsonObject hour_obj = hour_codes[i];
                            if (hour_obj["color_code"]) {
                              const char* color = hour_obj["color_code"];
                              next_hours += std::string(color);
                            }
                          }
                          id(next_12_hours) = next_hours;
                          
                          id(api_fetch_success) = true;
                          ESP_LOGD("API", "Data parsed successfully");
                          return true;
                        }
                      }
                      ESP_LOGD("API", "JSON parsing failed");
                      id(api_fetch_success) = false;
                      return false;
                    });
                  } else {
                    ESP_LOGD("API", "API call failed");
                    id(api_fetch_success) = false;
                  }